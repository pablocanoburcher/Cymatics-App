<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cymatics">
    <meta name="description" content="Visualize sound through physics with real-time Chladni patterns">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="icons/icon-152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-72.png">

    <title>Cymatics Audio Visualizer</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&display=swap');

        :root {
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            overscroll-behavior: none;
        }

        #container {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
            padding: 24px;
            padding-top: calc(24px + var(--safe-area-top));
            padding-bottom: calc(24px + var(--safe-area-bottom));
        }

        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #startScreen h1 {
            font-size: clamp(28px, 8vw, 48px);
            font-weight: 700;
            letter-spacing: 4px;
            margin-bottom: 12px;
            text-transform: uppercase;
            text-align: center;
        }

        #startScreen .subtitle {
            font-size: clamp(12px, 3vw, 14px);
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 48px;
            letter-spacing: 1px;
            text-align: center;
        }

        .input-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            max-width: 320px;
            margin-bottom: 32px;
        }

        @media (min-width: 600px) {
            .input-options {
                flex-direction: row;
                max-width: 480px;
            }
        }

        .input-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 24px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-height: 120px;
        }

        .input-option:hover, .input-option:active {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.3);
            transform: scale(0.98);
        }

        .input-option svg {
            width: 40px;
            height: 40px;
            margin-bottom: 12px;
            opacity: 0.8;
        }

        .input-option span {
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        #fileInput {
            display: none;
        }

        .start-hint {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.4);
            text-align: center;
            max-width: 280px;
            line-height: 1.5;
        }

        /* Install Prompt */
        #installPrompt {
            position: fixed;
            bottom: calc(24px + var(--safe-area-bottom));
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            z-index: 3000;
            display: none;
            gap: 8px;
            align-items: center;
        }

        #installPrompt.visible {
            display: flex;
        }

        #installPrompt svg {
            width: 16px;
            height: 16px;
        }

        /* Controls Panel - Mobile Drawer */
        #controlsDrawer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 70vh;
            overflow-y: auto;
            overscroll-behavior: contain;
            padding-bottom: var(--safe-area-bottom);
        }

        #controlsDrawer.visible {
            transform: translateY(0);
        }

        .drawer-handle {
            width: 36px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 12px auto;
        }

        .drawer-content {
            padding: 0 20px 20px;
        }

        .drawer-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .drawer-tabs::-webkit-scrollbar {
            display: none;
        }

        .drawer-tab {
            padding: 10px 16px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .drawer-tab.active {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.85);
        }

        .control-group label span {
            font-size: 12px;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.4);
            font-variant-numeric: tabular-nums;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 44px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 0;
            cursor: pointer;
            background: transparent;
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 44px;
            background: transparent;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            margin-top: -10px;
        }

        .control-group input[type="range"]::-moz-range-track {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        /* Status Bar */
        #statusBar {
            position: fixed;
            top: var(--safe-area-top);
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            z-index: 100;
            pointer-events: none;
        }

        #status {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 8px 14px;
            font-size: 10px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #status .indicator {
            width: 6px;
            height: 6px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        #status.error .indicator {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Floating Action Buttons */
        .fab-container {
            position: fixed;
            bottom: calc(20px + var(--safe-area-bottom));
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 500;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .fab-container.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .fab {
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .fab:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        .fab svg {
            width: 20px;
            height: 20px;
        }

        /* Audio Analysis Mini Display */
        #audioMini {
            position: fixed;
            top: calc(60px + var(--safe-area-top));
            left: 16px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            font-size: 10px;
            min-width: 100px;
        }

        #audioMini.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .mini-row {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 4px;
            color: rgba(255, 255, 255, 0.6);
        }

        .mini-row:last-child {
            margin-bottom: 0;
        }

        .mini-row .value {
            color: rgba(255, 255, 255, 0.9);
            font-variant-numeric: tabular-nums;
        }

        /* Mini Frequency Bars */
        #miniBars {
            display: flex;
            gap: 1px;
            height: 20px;
            margin-top: 8px;
            align-items: flex-end;
        }

        .mini-bar {
            flex: 1;
            background: rgba(255, 255, 255, 0.4);
            min-width: 2px;
            transition: height 0.05s ease;
        }

        /* Playback Controls - Mobile Optimized */
        #playbackBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 800;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            padding-bottom: var(--safe-area-bottom);
        }

        #playbackBar.visible {
            transform: translateY(0);
        }

        .playback-progress {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .playback-progress-fill {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.1s linear;
        }

        .playback-content {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            gap: 16px;
        }

        .playback-btn {
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        .playback-btn:active {
            opacity: 1;
        }

        .playback-btn.primary {
            width: 52px;
            height: 52px;
            background: #fff;
            color: #000;
            border-radius: 50%;
            opacity: 1;
        }

        .playback-btn.primary:active {
            transform: scale(0.95);
        }

        .playback-info {
            flex: 1;
            min-width: 0;
        }

        .playback-title {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playback-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            font-variant-numeric: tabular-nums;
        }

        .volume-btn {
            opacity: 0.6;
        }

        /* Volume Slider Popup */
        #volumePopup {
            position: fixed;
            bottom: calc(80px + var(--safe-area-bottom));
            right: 16px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            z-index: 900;
            display: none;
        }

        #volumePopup.visible {
            display: block;
        }

        #volumeSlider {
            width: 120px;
            height: 44px;
            -webkit-appearance: none;
            background: transparent;
        }

        #volumeSlider::-webkit-slider-runnable-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            margin-top: -8px;
        }

        /* Touch Gesture Indicator */
        #gestureHint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #gestureHint.visible {
            opacity: 1;
        }

        /* Desktop Overrides */
        @media (min-width: 768px) and (hover: hover) {
            #controlsDrawer {
                position: fixed;
                top: 80px;
                right: 20px;
                bottom: auto;
                left: auto;
                width: 320px;
                max-height: calc(100vh - 160px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 0;
                transform: translateX(calc(100% + 40px));
            }

            #controlsDrawer.visible {
                transform: translateX(0);
            }

            .drawer-handle {
                display: none;
            }

            .fab-container {
                bottom: 120px;
                right: 20px;
            }

            #audioMini {
                top: 80px;
                left: 20px;
                min-width: 200px;
            }

            #playbackBar {
                left: 50%;
                right: auto;
                transform: translateX(-50%) translateY(100%);
                width: auto;
                min-width: 400px;
                border-radius: 12px 12px 0 0;
            }

            #playbackBar.visible {
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Landscape Mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            #controlsDrawer {
                max-height: 60vh;
            }

            .input-options {
                flex-direction: row;
            }

            #startScreen h1 {
                font-size: 24px;
                margin-bottom: 8px;
            }

            #startScreen .subtitle {
                margin-bottom: 24px;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Cymatics</h1>
        <p class="subtitle">Visualize sound through physics</p>

        <div class="input-options">
            <div class="input-option" id="micOption">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                    <line x1="8" y1="23" x2="16" y2="23"/>
                </svg>
                <span>Microphone</span>
            </div>

            <div class="input-option" id="fileOption">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
                <span>Audio File</span>
            </div>
        </div>

        <input type="file" id="fileInput" accept="audio/*">

        <p class="start-hint">Use headphones for best experience. Tap the screen to show/hide controls.</p>
    </div>

    <!-- Install Prompt -->
    <div id="installPrompt">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        <span>Install App</span>
    </div>

    <!-- Main Container -->
    <div id="container"></div>

    <!-- Status Bar -->
    <div id="statusBar">
        <div id="status">
            <div class="indicator"></div>
            <span id="statusText">Ready</span>
        </div>
    </div>

    <!-- Audio Mini Display -->
    <div id="audioMini">
        <div class="mini-row">
            <span>Freq</span>
            <span class="value" id="miniFreq">-- Hz</span>
        </div>
        <div class="mini-row">
            <span>Energy</span>
            <span class="value" id="miniEnergy">--%</span>
        </div>
        <div id="miniBars"></div>
    </div>

    <!-- Floating Action Buttons -->
    <div class="fab-container" id="fabContainer">
        <button class="fab" id="infoFab" aria-label="Toggle audio info">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 20h.01"/>
                <path d="M12 16v-4"/>
                <path d="M12 8h.01"/>
                <circle cx="12" cy="12" r="10"/>
            </svg>
        </button>
        <button class="fab" id="settingsFab" aria-label="Open settings">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v10M4.22 4.22l4.24 4.24m7.08 7.08l4.24 4.24M1 12h6m6 0h10M4.22 19.78l4.24-4.24m7.08-7.08l4.24-4.24"/>
            </svg>
        </button>
    </div>

    <!-- Controls Drawer -->
    <div id="controlsDrawer">
        <div class="drawer-handle"></div>
        <div class="drawer-content">
            <div class="drawer-tabs">
                <button class="drawer-tab active" data-tab="visual">Visual</button>
                <button class="drawer-tab" data-tab="physics">Physics</button>
                <button class="drawer-tab" data-tab="pattern">Pattern</button>
            </div>

            <!-- Visual Tab -->
            <div class="tab-panel active" id="tab-visual">
                <div class="control-group">
                    <label>Plate Color</label>
                    <input type="color" id="plateColor" value="#0a0a0a">
                </div>
                <div class="control-group">
                    <label>Sand Color</label>
                    <input type="color" id="sandColor" value="#e8d5b7">
                </div>
                <div class="control-group">
                    <label>Particle Size <span id="sizeValue">3.0</span></label>
                    <input type="range" id="particleSize" min="1.0" max="8.0" step="0.5" value="3.0">
                </div>
            </div>

            <!-- Physics Tab -->
            <div class="tab-panel" id="tab-physics">
                <div class="control-group">
                    <label>Frequency Response <span id="freqValue">1.5</span></label>
                    <input type="range" id="freqResponse" min="0.1" max="5.0" step="0.1" value="1.5">
                </div>
                <div class="control-group">
                    <label>Friction <span id="frictionValue">0.94</span></label>
                    <input type="range" id="friction" min="0.80" max="0.99" step="0.01" value="0.94">
                </div>
                <div class="control-group">
                    <label>Pattern Complexity <span id="complexityValue">3.0</span></label>
                    <input type="range" id="complexity" min="1.0" max="8.0" step="0.5" value="3.0">
                </div>
                <div class="control-group">
                    <label>Harmonic Sensitivity <span id="harmonicValue">1.0</span></label>
                    <input type="range" id="harmonicSensitivity" min="0.0" max="3.0" step="0.1" value="1.0">
                </div>
            </div>

            <!-- Pattern Tab -->
            <div class="tab-panel" id="tab-pattern">
                <div class="control-group">
                    <label>Chladni Mode <span id="modeValue">2</span></label>
                    <input type="range" id="chladniMode" min="1" max="8" step="1" value="2">
                </div>
                <div class="control-group">
                    <label>Symmetry <span id="symmetryValue">4</span></label>
                    <input type="range" id="symmetry" min="2" max="12" step="1" value="4">
                </div>
            </div>
        </div>
    </div>

    <!-- Playback Bar -->
    <div id="playbackBar">
        <div class="playback-progress" id="progressBar">
            <div class="playback-progress-fill" id="progressFill"></div>
        </div>
        <div class="playback-content">
            <button class="playback-btn" id="prevBtn" aria-label="Previous">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 20L9 12l10-8v16zM7 19V5H5v14h2z"/>
                </svg>
            </button>
            <button class="playback-btn primary" id="playPauseBtn" aria-label="Play/Pause">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" id="pauseIcon" style="display:none">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                </svg>
            </button>
            <button class="playback-btn" id="nextBtn" aria-label="Next">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M5 4l10 8-10 8V4zm12 1v14h2V5h-2z"/>
                </svg>
            </button>
            <div class="playback-info">
                <div class="playback-title" id="trackName">No track loaded</div>
                <div class="playback-time" id="trackTime">0:00 / 0:00</div>
            </div>
            <button class="playback-btn volume-btn" id="volumeBtn" aria-label="Volume">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Volume Popup -->
    <div id="volumePopup">
        <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
    </div>

    <!-- Gesture Hint -->
    <div id="gestureHint"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // =====================================================
        // CYMATICS PWA - Mobile-Friendly Audio Visualizer
        // =====================================================

        // Configuration - optimized for mobile
        const CONFIG = {
            PARTICLE_COUNT: 96,         // Reduced for mobile (96x96 = 9,216 particles)
            PARTICLE_SIZE: 3.5,
            PLATE_RADIUS: 38,
            FFT_SIZE: 1024,             // Reduced for mobile performance
            SMOOTHING: 0.8,
            MAX_VELOCITY: 6.0,
            FREQUENCY_BANDS: 16         // Fewer bars for mini display
        };

        // Detect mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
            || window.innerWidth < 768;

        // Adjust config for desktop
        if (!isMobile) {
            CONFIG.PARTICLE_COUNT = 128;
            CONFIG.FFT_SIZE = 2048;
            CONFIG.FREQUENCY_BANDS = 24;
        }

        // Application State
        const state = {
            scene: null,
            camera: null,
            renderer: null,
            gpuCompute: null,
            positionVariable: null,
            velocityVariable: null,
            particleUniforms: null,
            particleMaterial: null,
            particleSystem: null,
            audioContext: null,
            analyser: null,
            dataArray: null,
            sourceNode: null,
            gainNode: null,
            audioElement: null,
            mediaStream: null,
            isAudioReady: false,
            isPlaying: false,
            inputMode: null,
            animationId: null,
            lastTime: Date.now(),
            frameCount: 0,
            showAudioInfo: false,
            showControls: false,

            // Touch state
            touch: {
                startY: 0,
                startX: 0,
                dragging: false
            },

            // Audio analysis data
            audioData: {
                dominantFrequency: 0,
                amplitude: 0,
                energy: 0,
                bass: 0,
                mids: 0,
                highs: 0
            }
        };

        // Uniforms for shaders
        const uniforms = {
            uPlateColor: { value: null },
            uSandColor: { value: null },
            uFrequencyResponse: { value: 1.5 },
            uFriction: { value: 0.94 },
            uComplexity: { value: 3.0 },
            uHarmonicSensitivity: { value: 1.0 },
            uChladniMode: { value: 2 },
            uSymmetry: { value: 4 },
            uTime: { value: 0 },
            uBass: { value: 0 },
            uMids: { value: 0 },
            uHighs: { value: 0 },
            uEnergy: { value: 0 }
        };

        // PWA Install
        let deferredPrompt = null;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('installPrompt')?.classList.add('visible');
        });

        document.getElementById('installPrompt')?.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log('Install prompt outcome:', outcome);
                deferredPrompt = null;
                document.getElementById('installPrompt')?.classList.remove('visible');
            }
        });

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('SW registered:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('SW registration failed:', error);
                    });
            });
        }

        // =====================================================
        // INITIALIZATION
        // =====================================================

        function init() {
            console.log('Initializing Cymatics PWA...');
            console.log('Mobile mode:', isMobile);

            uniforms.uPlateColor.value = new THREE.Color(0x0a0a0a);
            uniforms.uSandColor.value = new THREE.Color(0xe8d5b7);

            initScene();
            initGPUComputation();
            initParticles();
            initMiniBars();
            setupEventListeners();
            setupTouchGestures();

            animate();

            updateStatus('Select audio source');
            console.log('Initialization complete');
        }

        function initScene() {
            state.scene = new THREE.Scene();
            state.scene.background = uniforms.uPlateColor.value;

            state.camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            state.camera.position.z = isMobile ? 55 : 65;

            state.renderer = new THREE.WebGLRenderer({
                antialias: !isMobile,
                alpha: false,
                powerPreference: isMobile ? "default" : "high-performance"
            });
            state.renderer.setSize(window.innerWidth, window.innerHeight);
            state.renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 2));

            const container = document.getElementById('container');
            if (container) {
                container.appendChild(state.renderer.domElement);
            }

            console.log('Scene initialized. WebGL2:', state.renderer.capabilities.isWebGL2);
        }

        // =====================================================
        // GPU COMPUTATION
        // =====================================================

        function initGPUComputation() {
            state.gpuCompute = new GPUComputationRenderer(
                CONFIG.PARTICLE_COUNT,
                CONFIG.PARTICLE_COUNT,
                state.renderer
            );

            if (!state.gpuCompute.isSupported()) {
                console.error('GPUComputationRenderer not supported');
                updateStatus('WebGL not supported', true);
                return;
            }

            const dtPosition = state.gpuCompute.createTexture();
            const dtVelocity = state.gpuCompute.createTexture();

            fillTextures(dtPosition, dtVelocity);

            state.positionVariable = state.gpuCompute.addVariable(
                "texturePosition",
                getPositionShader(),
                dtPosition
            );

            state.velocityVariable = state.gpuCompute.addVariable(
                "textureVelocity",
                getVelocityShader(),
                dtVelocity
            );

            state.gpuCompute.setVariableDependencies(state.positionVariable, [state.positionVariable, state.velocityVariable]);
            state.gpuCompute.setVariableDependencies(state.velocityVariable, [state.positionVariable, state.velocityVariable]);

            const posUniforms = state.positionVariable.material.uniforms;
            posUniforms.uTime = { value: 0 };
            posUniforms.uDeltaTime = { value: 0 };
            posUniforms.uPlateRadius = { value: CONFIG.PLATE_RADIUS };

            const velUniforms = state.velocityVariable.material.uniforms;
            velUniforms.uTime = { value: 0 };
            velUniforms.uDeltaTime = { value: 0 };
            velUniforms.uFrequencyData = { value: null };
            velUniforms.uFrequencyResponse = uniforms.uFrequencyResponse;
            velUniforms.uFriction = uniforms.uFriction;
            velUniforms.uComplexity = uniforms.uComplexity;
            velUniforms.uHarmonicSensitivity = uniforms.uHarmonicSensitivity;
            velUniforms.uChladniMode = uniforms.uChladniMode;
            velUniforms.uSymmetry = uniforms.uSymmetry;
            velUniforms.uBass = uniforms.uBass;
            velUniforms.uMids = uniforms.uMids;
            velUniforms.uHighs = uniforms.uHighs;
            velUniforms.uEnergy = uniforms.uEnergy;
            velUniforms.uPlateRadius = { value: CONFIG.PLATE_RADIUS };

            const error = state.gpuCompute.init();
            if (error !== null) {
                console.error('GPU Compute init error:', error);
                updateStatus('GPU initialization failed', true);
            }
        }

        function fillTextures(texturePosition, textureVelocity) {
            const posArray = texturePosition.image.data;
            const velArray = textureVelocity.image.data;
            const radius = CONFIG.PLATE_RADIUS;

            for (let k = 0; k < posArray.length; k += 4) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * radius;

                posArray[k + 0] = Math.cos(angle) * r;
                posArray[k + 1] = Math.sin(angle) * r;
                posArray[k + 2] = (Math.random() - 0.5) * 0.2;
                posArray[k + 3] = 1.0;

                velArray[k + 0] = 0;
                velArray[k + 1] = 0;
                velArray[k + 2] = 0;
                velArray[k + 3] = 1.0;
            }
        }

        // =====================================================
        // SHADERS
        // =====================================================

        function getPositionShader() {
            return `
                uniform float uTime;
                uniform float uDeltaTime;
                uniform float uPlateRadius;

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVelocity, uv);

                    pos.xyz += vel.xyz * uDeltaTime * 12.0;

                    float dist = length(pos.xy);
                    if (dist > uPlateRadius) {
                        pos.xy = normalize(pos.xy) * uPlateRadius;
                        vec2 normal = normalize(pos.xy);
                        vel.xy = vel.xy - 2.0 * dot(vel.xy, normal) * normal;
                        vel.xy *= 0.5;
                    }

                    pos.z = mix(pos.z, 0.0, 0.15);

                    gl_FragColor = pos;
                }
            `;
        }

        function getVelocityShader() {
            return `
                uniform float uTime;
                uniform float uDeltaTime;
                uniform sampler2D uFrequencyData;
                uniform float uFrequencyResponse;
                uniform float uFriction;
                uniform float uComplexity;
                uniform float uHarmonicSensitivity;
                uniform float uChladniMode;
                uniform float uSymmetry;
                uniform float uBass;
                uniform float uMids;
                uniform float uHighs;
                uniform float uEnergy;
                uniform float uPlateRadius;

                float chladniClassic(vec2 pos, float n, float m) {
                    float L = uPlateRadius * 2.0;
                    float x = pos.x + uPlateRadius;
                    float y = pos.y + uPlateRadius;
                    float pattern1 = cos(n * 3.14159 * x / L) * cos(m * 3.14159 * y / L);
                    float pattern2 = cos(m * 3.14159 * x / L) * cos(n * 3.14159 * y / L);
                    return pattern1 - pattern2;
                }

                float chladniCircular(vec2 pos, float mode, float symmetry) {
                    float r = length(pos) / uPlateRadius;
                    float theta = atan(pos.y, pos.x);
                    float radial = cos(mode * 3.14159 * r);
                    float angular = cos(symmetry * theta);
                    return radial * angular;
                }

                float chladniPattern(vec2 pos, float f1, float f2, float f3, float f4) {
                    float mode = uChladniMode;
                    float sym = uSymmetry;
                    float complexity = uComplexity;

                    float pattern = chladniCircular(pos, mode, sym);
                    pattern += chladniCircular(pos, mode + f1 * 2.0, sym) * f1 * 0.5;
                    pattern += chladniCircular(pos, mode + f2 * 3.0, sym + 2.0) * f2 * 0.3;
                    pattern += chladniClassic(pos, complexity + f3, complexity * 1.5 + f4) * 0.4;
                    pattern += chladniCircular(pos * 0.5, mode * 0.5, sym * 0.5) * uBass * 0.5;
                    pattern += chladniCircular(pos * 2.0, mode * 2.0, sym * 2.0) * uHighs * 0.3;

                    return pattern;
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 pos = texture2D(texturePosition, uv);
                    vec4 vel = texture2D(textureVelocity, uv);

                    float freq1 = texture2D(uFrequencyData, vec2(0.05, 0.5)).r;
                    float freq2 = texture2D(uFrequencyData, vec2(0.15, 0.5)).r;
                    float freq3 = texture2D(uFrequencyData, vec2(0.35, 0.5)).r;
                    float freq4 = texture2D(uFrequencyData, vec2(0.55, 0.5)).r;
                    float freq5 = texture2D(uFrequencyData, vec2(0.75, 0.5)).r;
                    float freq6 = texture2D(uFrequencyData, vec2(0.9, 0.5)).r;

                    float pattern = chladniPattern(pos.xy * 0.08, freq1, freq2, freq3, freq4);

                    float delta = 0.15;
                    float px = chladniPattern((pos.xy + vec2(delta, 0.0)) * 0.08, freq1, freq2, freq3, freq4);
                    float py = chladniPattern((pos.xy + vec2(0.0, delta)) * 0.08, freq1, freq2, freq3, freq4);

                    vec2 gradient = vec2(px - pattern, py - pattern) / delta;

                    float intensity = (freq1 + freq2 + freq3 + freq4 + freq5 + freq6) / 6.0;
                    intensity *= uEnergy;
                    intensity *= (1.0 + uHarmonicSensitivity * (freq3 + freq4) * 0.5);

                    vec2 force = -gradient * intensity * uFrequencyResponse * 3.0;

                    float bassForce = uBass * sin(uTime * 10.0 + length(pos.xy) * 0.5);
                    force += normalize(pos.xy + vec2(0.001)) * bassForce * 0.3;

                    float noise = fract(sin(dot(pos.xy, vec2(12.9898, 78.233)) + uTime * 2.0) * 43758.5453);
                    force += (vec2(noise, fract(noise * 2.0)) - 0.5) * intensity * 0.15;

                    float turbulence = sin(pos.x * 0.5 + uTime) * cos(pos.y * 0.5 + uTime * 1.3);
                    force += vec2(turbulence, -turbulence) * uEnergy * 0.2;

                    vel.xy += force * uDeltaTime;
                    vel.xyz *= uFriction;

                    float speed = length(vel.xy);
                    if (speed > 6.0) {
                        vel.xy = normalize(vel.xy) * 6.0;
                    }

                    vel.z *= 0.9;

                    gl_FragColor = vel;
                }
            `;
        }

        function getParticleVertexShader() {
            return `
                uniform sampler2D texturePosition;
                uniform float uParticleSize;
                uniform float uTime;

                varying vec3 vPosition;
                varying float vRandom;
                varying float vDepth;

                void main() {
                    vec4 posTemp = texture2D(texturePosition, uv);
                    vec3 pos = posTemp.xyz;

                    vPosition = pos;
                    vRandom = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    vDepth = -mvPosition.z;

                    float size = uParticleSize * (280.0 / -mvPosition.z);
                    size *= (0.7 + vRandom * 0.6);

                    gl_PointSize = size;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;
        }

        function getParticleFragmentShader() {
            return `
                uniform vec3 uSandColor;
                uniform float uTime;

                varying vec3 vPosition;
                varying float vRandom;
                varying float vDepth;

                void main() {
                    vec2 center = gl_PointCoord - vec2(0.5);
                    float dist = length(center);

                    if (dist > 0.5) {
                        discard;
                    }

                    float alpha = smoothstep(0.5, 0.2, dist);

                    vec3 color = uSandColor;
                    color += (vRandom - 0.5) * 0.12;

                    float depthShade = 1.0 - (vDepth - 50.0) * 0.01;
                    color *= clamp(depthShade, 0.7, 1.0);

                    float highlight = pow(max(0.0, 1.0 - dist * 2.2), 4.0) * 0.4;
                    color += vec3(highlight);

                    float grain = fract(sin(dot(gl_PointCoord * 100.0, vec2(12.9898, 78.233))) * 43758.5453);
                    color += (grain - 0.5) * 0.04;

                    gl_FragColor = vec4(color, alpha * 0.95);
                }
            `;
        }

        // =====================================================
        // PARTICLE SYSTEM
        // =====================================================

        function initParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = CONFIG.PARTICLE_COUNT * CONFIG.PARTICLE_COUNT;

            const positions = new Float32Array(count * 3);
            const uvs = new Float32Array(count * 2);

            let p = 0;
            for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                for (let j = 0; j < CONFIG.PARTICLE_COUNT; j++) {
                    positions[p * 3 + 0] = 0;
                    positions[p * 3 + 1] = 0;
                    positions[p * 3 + 2] = 0;

                    uvs[p * 2 + 0] = i / CONFIG.PARTICLE_COUNT;
                    uvs[p * 2 + 1] = j / CONFIG.PARTICLE_COUNT;

                    p++;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

            state.particleUniforms = {
                texturePosition: { value: null },
                uSandColor: uniforms.uSandColor,
                uParticleSize: { value: CONFIG.PARTICLE_SIZE },
                uTime: { value: 0 }
            };

            state.particleMaterial = new THREE.ShaderMaterial({
                uniforms: state.particleUniforms,
                vertexShader: getParticleVertexShader(),
                fragmentShader: getParticleFragmentShader(),
                transparent: true,
                depthTest: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            state.particleSystem = new THREE.Points(geometry, state.particleMaterial);
            state.scene.add(state.particleSystem);

            console.log('Particle system created:', count, 'particles');
        }

        // =====================================================
        // AUDIO SYSTEM
        // =====================================================

        async function initAudioFromMicrophone() {
            try {
                updateStatus('Requesting microphone...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                state.mediaStream = stream;
                state.inputMode = 'microphone';

                setupAudioContext();

                state.sourceNode = state.audioContext.createMediaStreamSource(stream);
                state.sourceNode.connect(state.analyser);

                completeAudioSetup();
                updateStatus('Listening');

                return true;
            } catch (err) {
                console.error('Microphone access failed:', err);
                updateStatus('Microphone denied', true);
                return false;
            }
        }

        async function initAudioFromFile(file) {
            try {
                updateStatus('Loading...');

                state.audioElement = new Audio();
                state.audioElement.src = URL.createObjectURL(file);
                state.audioElement.loop = true;

                state.inputMode = 'file';

                setupAudioContext();

                await new Promise((resolve, reject) => {
                    state.audioElement.addEventListener('canplaythrough', resolve, { once: true });
                    state.audioElement.addEventListener('error', reject, { once: true });
                });

                state.sourceNode = state.audioContext.createMediaElementSource(state.audioElement);

                state.gainNode = state.audioContext.createGain();
                state.gainNode.gain.value = 1.0;

                state.sourceNode.connect(state.gainNode);
                state.gainNode.connect(state.audioContext.destination);
                state.sourceNode.connect(state.analyser);

                completeAudioSetup();

                document.getElementById('trackName').textContent = file.name.replace(/\.[^/.]+$/, '');

                await state.audioElement.play();
                state.isPlaying = true;
                updatePlayPauseButton();

                updateStatus('Playing');

                return true;
            } catch (err) {
                console.error('Audio file load failed:', err);
                updateStatus('Load failed', true);
                return false;
            }
        }

        function setupAudioContext() {
            state.audioContext = new (window.AudioContext || window.webkitAudioContext)();

            state.analyser = state.audioContext.createAnalyser();
            state.analyser.fftSize = CONFIG.FFT_SIZE;
            state.analyser.smoothingTimeConstant = CONFIG.SMOOTHING;

            state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);

            console.log('Audio context created. FFT bins:', state.analyser.frequencyBinCount);
        }

        function completeAudioSetup() {
            const frequencyTexture = new THREE.DataTexture(
                state.dataArray,
                state.analyser.frequencyBinCount,
                1,
                THREE.RedFormat,
                THREE.UnsignedByteType
            );
            frequencyTexture.needsUpdate = true;

            if (state.velocityVariable && state.velocityVariable.material) {
                state.velocityVariable.material.uniforms.uFrequencyData.value = frequencyTexture;
            }

            state.gpuCompute.compute();
            state.particleUniforms.texturePosition.value =
                state.gpuCompute.getCurrentRenderTarget(state.positionVariable).texture;

            state.isAudioReady = true;

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('fabContainer').classList.add('visible');
            document.getElementById('audioMini').classList.add('visible');

            if (state.inputMode === 'file') {
                document.getElementById('playbackBar').classList.add('visible');
            }
        }

        // =====================================================
        // AUDIO ANALYSIS
        // =====================================================

        function analyzeAudio() {
            if (!state.isAudioReady || !state.analyser) return;

            state.analyser.getByteFrequencyData(state.dataArray);

            const bufferLength = state.dataArray.length;
            const sampleRate = state.audioContext.sampleRate;
            const nyquist = sampleRate / 2;
            const binSize = nyquist / bufferLength;

            const bassEnd = Math.floor(250 / binSize);
            const midsEnd = Math.floor(2000 / binSize);

            let bassSum = 0, midsSum = 0, highsSum = 0;
            let totalSum = 0;
            let maxVal = 0;
            let maxIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                const value = state.dataArray[i] / 255;
                totalSum += value;

                if (i < bassEnd) {
                    bassSum += value;
                } else if (i < midsEnd) {
                    midsSum += value;
                } else {
                    highsSum += value;
                }

                if (value > maxVal) {
                    maxVal = value;
                    maxIndex = i;
                }
            }

            state.audioData.bass = bassSum / bassEnd;
            state.audioData.mids = midsSum / (midsEnd - bassEnd);
            state.audioData.highs = highsSum / (bufferLength - midsEnd);
            state.audioData.energy = totalSum / bufferLength;
            state.audioData.dominantFrequency = maxIndex * binSize;

            const frequencyTexture = state.velocityVariable?.material?.uniforms?.uFrequencyData?.value;
            if (frequencyTexture) {
                frequencyTexture.image.data.set(state.dataArray);
                frequencyTexture.needsUpdate = true;
            }

            if (state.velocityVariable?.material?.uniforms) {
                const u = state.velocityVariable.material.uniforms;
                u.uBass.value = state.audioData.bass;
                u.uMids.value = state.audioData.mids;
                u.uHighs.value = state.audioData.highs;
                u.uEnergy.value = state.audioData.energy;
            }

            updateMiniDisplay();
        }

        function updateMiniDisplay() {
            document.getElementById('miniFreq').textContent =
                state.audioData.dominantFrequency.toFixed(0) + ' Hz';
            document.getElementById('miniEnergy').textContent =
                (state.audioData.energy * 100).toFixed(0) + '%';

            updateMiniBars();
        }

        function initMiniBars() {
            const container = document.getElementById('miniBars');
            if (!container) return;

            container.innerHTML = '';
            for (let i = 0; i < CONFIG.FREQUENCY_BANDS; i++) {
                const bar = document.createElement('div');
                bar.className = 'mini-bar';
                container.appendChild(bar);
            }
        }

        function updateMiniBars() {
            const bars = document.querySelectorAll('.mini-bar');
            if (!bars.length || !state.dataArray) return;

            const binCount = state.dataArray.length;
            const binsPerBar = Math.floor(binCount / bars.length);

            bars.forEach((bar, i) => {
                let sum = 0;
                const start = i * binsPerBar;
                for (let j = start; j < start + binsPerBar; j++) {
                    sum += state.dataArray[j] || 0;
                }
                const average = sum / binsPerBar / 255;
                bar.style.height = (average * 100) + '%';
                bar.style.background = `rgba(255, 255, 255, ${0.3 + average * 0.7})`;
            });
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================

        function animate() {
            state.animationId = requestAnimationFrame(animate);

            const currentTime = Date.now();
            const deltaTime = Math.min((currentTime - state.lastTime) / 1000, 0.1);
            state.lastTime = currentTime;
            state.frameCount++;

            if (state.isAudioReady) {
                analyzeAudio();

                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uTime.value = currentTime / 1000;
                    state.velocityVariable.material.uniforms.uDeltaTime.value = deltaTime;
                }

                if (state.positionVariable?.material?.uniforms) {
                    state.positionVariable.material.uniforms.uTime.value = currentTime / 1000;
                    state.positionVariable.material.uniforms.uDeltaTime.value = deltaTime;
                }

                if (state.gpuCompute) {
                    state.gpuCompute.compute();

                    const posTexture = state.gpuCompute.getCurrentRenderTarget(state.positionVariable).texture;
                    state.particleUniforms.texturePosition.value = posTexture;
                    state.particleUniforms.uTime.value = currentTime / 1000;
                }

                if (state.inputMode === 'file' && state.audioElement) {
                    updatePlaybackProgress();
                }
            }

            state.renderer.render(state.scene, state.camera);
        }

        function updatePlaybackProgress() {
            const audio = state.audioElement;
            if (!audio || !audio.duration) return;

            const progress = (audio.currentTime / audio.duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            const current = formatTime(audio.currentTime);
            const total = formatTime(audio.duration);
            document.getElementById('trackTime').textContent = current + ' / ' + total;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return mins + ':' + (secs < 10 ? '0' : '') + secs;
        }

        // =====================================================
        // EVENT HANDLERS
        // =====================================================

        function setupEventListeners() {
            document.getElementById('micOption')?.addEventListener('click', initAudioFromMicrophone);

            document.getElementById('fileOption')?.addEventListener('click', () => {
                document.getElementById('fileInput')?.click();
            });

            document.getElementById('fileInput')?.addEventListener('change', (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    initAudioFromFile(file);
                }
            });

            // FAB buttons
            document.getElementById('infoFab')?.addEventListener('click', () => {
                state.showAudioInfo = !state.showAudioInfo;
                document.getElementById('audioMini')?.classList.toggle('visible', state.showAudioInfo);
            });

            document.getElementById('settingsFab')?.addEventListener('click', () => {
                state.showControls = !state.showControls;
                document.getElementById('controlsDrawer')?.classList.toggle('visible', state.showControls);
            });

            // Drawer tabs
            document.querySelectorAll('.drawer-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const tabName = e.target.dataset.tab;

                    document.querySelectorAll('.drawer-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));

                    e.target.classList.add('active');
                    document.getElementById(`tab-${tabName}`)?.classList.add('active');
                });
            });

            setupControlListeners();
            setupPlaybackControls();

            window.addEventListener('resize', onWindowResize);
        }

        function setupTouchGestures() {
            const container = document.getElementById('container');

            // Tap to toggle UI
            container?.addEventListener('click', (e) => {
                if (!state.isAudioReady) return;

                // Toggle audio mini display
                state.showAudioInfo = !state.showAudioInfo;
                document.getElementById('audioMini')?.classList.toggle('visible', state.showAudioInfo);
            });

            // Drawer drag gesture
            const drawer = document.getElementById('controlsDrawer');
            const handle = drawer?.querySelector('.drawer-handle');

            handle?.addEventListener('touchstart', (e) => {
                state.touch.startY = e.touches[0].clientY;
                state.touch.dragging = true;
            });

            document.addEventListener('touchmove', (e) => {
                if (!state.touch.dragging) return;

                const deltaY = e.touches[0].clientY - state.touch.startY;

                if (deltaY > 50) {
                    state.showControls = false;
                    drawer?.classList.remove('visible');
                    state.touch.dragging = false;
                }
            });

            document.addEventListener('touchend', () => {
                state.touch.dragging = false;
            });

            // Prevent default touch behaviors
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('input[type="range"]')) return;
                if (e.target.closest('#controlsDrawer')) return;
                e.preventDefault();
            }, { passive: false });
        }

        function setupControlListeners() {
            document.getElementById('plateColor')?.addEventListener('input', (e) => {
                uniforms.uPlateColor.value.set(e.target.value);
                state.scene.background = uniforms.uPlateColor.value;
            });

            document.getElementById('sandColor')?.addEventListener('input', (e) => {
                uniforms.uSandColor.value.set(e.target.value);
            });

            document.getElementById('particleSize')?.addEventListener('input', (e) => {
                state.particleUniforms.uParticleSize.value = parseFloat(e.target.value);
                document.getElementById('sizeValue').textContent = e.target.value;
            });

            document.getElementById('freqResponse')?.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                uniforms.uFrequencyResponse.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uFrequencyResponse.value = val;
                }
                document.getElementById('freqValue').textContent = val.toFixed(1);
            });

            document.getElementById('friction')?.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                uniforms.uFriction.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uFriction.value = val;
                }
                document.getElementById('frictionValue').textContent = val.toFixed(2);
            });

            document.getElementById('complexity')?.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                uniforms.uComplexity.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uComplexity.value = val;
                }
                document.getElementById('complexityValue').textContent = val.toFixed(1);
            });

            document.getElementById('harmonicSensitivity')?.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                uniforms.uHarmonicSensitivity.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uHarmonicSensitivity.value = val;
                }
                document.getElementById('harmonicValue').textContent = val.toFixed(1);
            });

            document.getElementById('chladniMode')?.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                uniforms.uChladniMode.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uChladniMode.value = val;
                }
                document.getElementById('modeValue').textContent = val;
            });

            document.getElementById('symmetry')?.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                uniforms.uSymmetry.value = val;
                if (state.velocityVariable?.material?.uniforms) {
                    state.velocityVariable.material.uniforms.uSymmetry.value = val;
                }
                document.getElementById('symmetryValue').textContent = val;
            });
        }

        function setupPlaybackControls() {
            document.getElementById('playPauseBtn')?.addEventListener('click', togglePlayPause);

            document.getElementById('volumeBtn')?.addEventListener('click', () => {
                document.getElementById('volumePopup')?.classList.toggle('visible');
            });

            document.getElementById('volumeSlider')?.addEventListener('input', (e) => {
                if (state.gainNode) {
                    state.gainNode.gain.value = parseFloat(e.target.value);
                }
            });

            document.getElementById('progressBar')?.addEventListener('click', (e) => {
                if (!state.audioElement) return;
                const rect = e.target.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                state.audioElement.currentTime = percent * state.audioElement.duration;
            });

            document.getElementById('prevBtn')?.addEventListener('click', () => {
                if (state.audioElement) {
                    state.audioElement.currentTime = 0;
                }
            });

            // Close volume popup when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#volumePopup') && !e.target.closest('#volumeBtn')) {
                    document.getElementById('volumePopup')?.classList.remove('visible');
                }
            });
        }

        function togglePlayPause() {
            if (!state.audioElement) return;

            if (state.isPlaying) {
                state.audioElement.pause();
                state.isPlaying = false;
            } else {
                state.audioElement.play();
                state.isPlaying = true;
            }

            updatePlayPauseButton();
        }

        function updatePlayPauseButton() {
            const playIcon = document.getElementById('playIcon');
            const pauseIcon = document.getElementById('pauseIcon');

            if (playIcon && pauseIcon) {
                playIcon.style.display = state.isPlaying ? 'none' : 'block';
                pauseIcon.style.display = state.isPlaying ? 'block' : 'none';
            }
        }

        function onWindowResize() {
            state.camera.aspect = window.innerWidth / window.innerHeight;
            state.camera.updateProjectionMatrix();
            state.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateStatus(text, isError = false) {
            const statusEl = document.getElementById('status');
            const textEl = document.getElementById('statusText');

            if (textEl) {
                textEl.textContent = text;
            }

            if (statusEl) {
                statusEl.classList.toggle('error', isError);
            }
        }

        function showGestureHint(text) {
            const hint = document.getElementById('gestureHint');
            if (hint) {
                hint.textContent = text;
                hint.classList.add('visible');
                setTimeout(() => hint.classList.remove('visible'), 1500);
            }
        }

        // =====================================================
        // GPU COMPUTATION RENDERER
        // =====================================================

        class GPUComputationRenderer {
            constructor(sizeX, sizeY, renderer) {
                this.variables = [];
                this.currentTextureIndex = 0;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.renderer = renderer;

                const dataType = THREE.FloatType;

                this.scene = new THREE.Scene();
                this.camera = new THREE.Camera();
                this.camera.position.z = 1;

                this.passThruUniforms = {
                    passThruTexture: { value: null }
                };

                this.passThruShader = this.createShaderMaterial(
                    this.getPassThroughFragmentShader(),
                    this.passThruUniforms
                );

                this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.passThruShader);
                this.scene.add(this.mesh);

                this.dataType = dataType;
            }

            getPassThroughVertexShader() {
                return `void main() { gl_Position = vec4(position, 1.0); }`;
            }

            getPassThroughFragmentShader() {
                return `
                    uniform sampler2D passThruTexture;
                    void main() {
                        vec2 uv = gl_FragCoord.xy / resolution.xy;
                        gl_FragColor = texture2D(passThruTexture, uv);
                    }
                `;
            }

            addResolutionDefine(material) {
                material.defines = material.defines || {};
                material.defines.resolution = `vec2(${this.sizeX.toFixed(1)}, ${this.sizeY.toFixed(1)})`;
            }

            createShaderMaterial(fragmentShader, uniforms = {}) {
                const material = new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: this.getPassThroughVertexShader(),
                    fragmentShader: fragmentShader
                });
                this.addResolutionDefine(material);
                return material;
            }

            createTexture() {
                const data = new Float32Array(this.sizeX * this.sizeY * 4);
                return new THREE.DataTexture(data, this.sizeX, this.sizeY, THREE.RGBAFormat, THREE.FloatType);
            }

            addVariable(name, fragmentShader, initialTexture) {
                const material = this.createShaderMaterial(fragmentShader);

                const variable = {
                    name: name,
                    initialValueTexture: initialTexture,
                    material: material,
                    dependencies: null,
                    renderTargets: [],
                    wrapS: null,
                    wrapT: null,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter
                };

                this.variables.push(variable);
                return variable;
            }

            setVariableDependencies(variable, dependencies) {
                variable.dependencies = dependencies;
            }

            init() {
                if (!this.renderer.capabilities.isWebGL2 &&
                    !this.renderer.extensions.get('OES_texture_float')) {
                    return 'Float textures not supported';
                }

                if (this.renderer.capabilities.maxVertexTextures === 0) {
                    return 'Vertex textures not supported';
                }

                for (const variable of this.variables) {
                    variable.renderTargets[0] = this.createRenderTarget();
                    variable.renderTargets[1] = this.createRenderTarget();

                    this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);
                    this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);

                    const uniforms = variable.material.uniforms;

                    if (variable.dependencies) {
                        for (const dep of variable.dependencies) {
                            if (dep.name !== variable.name && !uniforms[dep.name]) {
                                uniforms[dep.name] = { value: null };
                            }
                        }
                    }
                }

                this.currentTextureIndex = 0;
                return null;
            }

            compute() {
                const currentIndex = this.currentTextureIndex;
                const nextIndex = currentIndex === 0 ? 1 : 0;

                for (const variable of this.variables) {
                    if (variable.dependencies) {
                        const uniforms = variable.material.uniforms;
                        for (const dep of variable.dependencies) {
                            if (uniforms[dep.name]) {
                                uniforms[dep.name].value = dep.renderTargets[currentIndex].texture;
                            }
                        }
                    }

                    this.doRenderTarget(variable.material, variable.renderTargets[nextIndex]);
                }

                this.currentTextureIndex = nextIndex;
            }

            getCurrentRenderTarget(variable) {
                return variable.renderTargets[this.currentTextureIndex];
            }

            createRenderTarget() {
                return new THREE.WebGLRenderTarget(this.sizeX, this.sizeY, {
                    wrapS: THREE.ClampToEdgeWrapping,
                    wrapT: THREE.ClampToEdgeWrapping,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    type: this.dataType,
                    depthBuffer: false
                });
            }

            renderTexture(input, output) {
                this.passThruUniforms.passThruTexture.value = input;
                this.doRenderTarget(this.passThruShader, output);
                this.passThruUniforms.passThruTexture.value = null;
            }

            doRenderTarget(material, output) {
                const currentRenderTarget = this.renderer.getRenderTarget();
                const currentXrEnabled = this.renderer.xr.enabled;
                const currentShadowAutoUpdate = this.renderer.shadowMap.autoUpdate;

                this.renderer.xr.enabled = false;
                this.renderer.shadowMap.autoUpdate = false;

                this.mesh.material = material;
                this.renderer.setRenderTarget(output);
                this.renderer.render(this.scene, this.camera);

                this.renderer.xr.enabled = currentXrEnabled;
                this.renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
                this.renderer.setRenderTarget(currentRenderTarget);
            }

            isSupported() {
                return this.renderer.capabilities.isWebGL2 ||
                       this.renderer.extensions.get('OES_texture_float');
            }
        }

        // =====================================================
        // START APPLICATION
        // =====================================================

        window.addEventListener('load', () => {
            init();
        });
    </script>
</body>
</html>
