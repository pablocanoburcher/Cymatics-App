<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cymatics">
    <meta name="description" content="Visualize sound through atomic orbital geometry patterns">

    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-152.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-72.png">

    <title>Cymatics - Orbital Sound Visualizer</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700&display=swap');

        :root {
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            font-family: 'Manrope', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #000;
            color: #fff;
            overscroll-behavior: none;
        }

        #container {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
        }

        /* Start Screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: radial-gradient(ellipse at center, #0a0a15 0%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.8s ease;
            padding: 24px;
        }

        #startScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #startScreen h1 {
            font-size: clamp(32px, 10vw, 56px);
            font-weight: 300;
            letter-spacing: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            text-align: center;
            background: linear-gradient(135deg, #fff 0%, #88f 50%, #fff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #startScreen .subtitle {
            font-size: clamp(11px, 3vw, 14px);
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 60px;
            letter-spacing: 3px;
            text-align: center;
            text-transform: uppercase;
        }

        .input-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            max-width: 300px;
        }

        @media (min-width: 500px) {
            .input-options {
                flex-direction: row;
                max-width: 500px;
            }
        }

        .input-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 28px 24px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
        }

        .input-option:hover, .input-option:active {
            background: rgba(100, 120, 255, 0.1);
            border-color: rgba(100, 120, 255, 0.3);
            transform: scale(0.98);
        }

        .input-option svg {
            width: 36px;
            height: 36px;
            margin-bottom: 14px;
            opacity: 0.7;
            stroke: #99f;
        }

        .input-option span {
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
        }

        #fileInput {
            display: none;
        }

        /* Status */
        #status {
            position: fixed;
            top: calc(16px + var(--safe-area-top));
            left: 16px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 10px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #status .indicator {
            width: 6px;
            height: 6px;
            background: #4f8;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 8px #4f8; }
            50% { opacity: 0.5; box-shadow: 0 0 2px #4f8; }
        }

        /* Controls Button */
        #controlsBtn {
            position: fixed;
            top: calc(16px + var(--safe-area-top));
            right: 16px;
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        #controlsBtn.visible {
            display: flex;
        }

        /* Controls Panel */
        #controlsPanel {
            position: fixed;
            top: calc(70px + var(--safe-area-top));
            right: 16px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(30px);
            -webkit-backdrop-filter: blur(30px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            display: none;
            min-width: 240px;
        }

        #controlsPanel.visible {
            display: block;
        }

        .control-group {
            margin-bottom: 18px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
        }

        .control-group label span {
            color: rgba(255, 255, 255, 0.4);
        }

        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 32px;
            background: transparent;
        }

        .control-group input[type="range"]::-webkit-slider-runnable-track {
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #fff;
            border-radius: 50%;
            margin-top: -7px;
            cursor: pointer;
        }

        /* Audio Info */
        #audioInfo {
            position: fixed;
            bottom: calc(100px + var(--safe-area-bottom));
            left: 16px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            padding: 14px 18px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 11px;
            z-index: 100;
            display: none;
        }

        #audioInfo.visible {
            display: block;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 6px;
            color: rgba(255, 255, 255, 0.5);
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-row .value {
            color: rgba(255, 255, 255, 0.9);
            font-variant-numeric: tabular-nums;
        }

        /* Playback Bar */
        #playbackBar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(30px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: var(--safe-area-bottom);
            z-index: 100;
            display: none;
        }

        #playbackBar.visible {
            display: block;
        }

        .progress-bar {
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #66f, #a6f);
            width: 0%;
            transition: width 0.1s linear;
        }

        .playback-content {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            gap: 16px;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            background: #fff;
            border: none;
            border-radius: 50%;
            color: #000;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-time {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 2px;
        }

        .vol-btn {
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Cymatics</h1>
        <p class="subtitle">Orbital Sound Geometry</p>

        <div class="input-options">
            <div class="input-option" id="micOption">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    <line x1="12" y1="19" x2="12" y2="23"/>
                    <line x1="8" y1="23" x2="16" y2="23"/>
                </svg>
                <span>Microphone</span>
            </div>

            <div class="input-option" id="fileOption">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
                <span>Audio File</span>
            </div>
        </div>

        <input type="file" id="fileInput" accept="audio/*">
    </div>

    <!-- Main Canvas -->
    <div id="container"></div>

    <!-- Status -->
    <div id="status">
        <div class="indicator"></div>
        <span id="statusText">Ready</span>
    </div>

    <!-- Controls Button -->
    <button id="controlsBtn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
        </svg>
    </button>

    <!-- Controls Panel -->
    <div id="controlsPanel">
        <div class="control-group">
            <label>Complexity <span id="complexityVal">5</span></label>
            <input type="range" id="complexity" min="3" max="12" step="1" value="5">
        </div>
        <div class="control-group">
            <label>Symmetry <span id="symmetryVal">8</span></label>
            <input type="range" id="symmetry" min="4" max="16" step="2" value="8">
        </div>
        <div class="control-group">
            <label>Sensitivity <span id="sensitivityVal">1.0</span></label>
            <input type="range" id="sensitivity" min="0.2" max="3.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label>Rotation <span id="rotationVal">0.5</span></label>
            <input type="range" id="rotation" min="0" max="2" step="0.1" value="0.5">
        </div>
    </div>

    <!-- Audio Info -->
    <div id="audioInfo">
        <div class="info-row">
            <span>Frequency</span>
            <span class="value" id="freqDisplay">-- Hz</span>
        </div>
        <div class="info-row">
            <span>Energy</span>
            <span class="value" id="energyDisplay">--%</span>
        </div>
    </div>

    <!-- Playback Bar -->
    <div id="playbackBar">
        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="playback-content">
            <button class="play-btn" id="playBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" id="pauseIcon" style="display:none">
                    <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                </svg>
            </button>
            <div class="track-info">
                <div class="track-name" id="trackName">No track</div>
                <div class="track-time" id="trackTime">0:00 / 0:00</div>
            </div>
            <button class="vol-btn" id="volBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                    <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                </svg>
            </button>
        </div>
    </div>

    <script>
        // =====================================================
        // CYMATICS - ORBITAL ATOMIC GEOMETRY VISUALIZER
        // Based on Mereon vibration patterns and CymaScope principles
        // =====================================================

        const CONFIG = {
            fftSize: 1024,
            smoothing: 0.8,
            complexity: 5,
            symmetry: 8,
            sensitivity: 1.0,
            rotationSpeed: 0.5
        };

        const state = {
            canvas: null,
            ctx: null,
            audioContext: null,
            analyser: null,
            dataArray: null,
            source: null,
            gainNode: null,
            audioElement: null,
            isPlaying: false,
            isReady: false,
            time: 0,
            audioData: {
                bass: 0,
                mid: 0,
                high: 0,
                energy: 0,
                dominantFreq: 0
            }
        };

        // =====================================================
        // INITIALIZATION
        // =====================================================

        function init() {
            // Create canvas
            state.canvas = document.createElement('canvas');
            state.ctx = state.canvas.getContext('2d');
            document.getElementById('container').appendChild(state.canvas);

            resize();
            window.addEventListener('resize', resize);

            // Event listeners
            document.getElementById('micOption').addEventListener('click', initMicrophone);
            document.getElementById('fileOption').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('fileInput').addEventListener('change', (e) => {
                if (e.target.files[0]) initAudioFile(e.target.files[0]);
            });

            // Controls
            document.getElementById('controlsBtn').addEventListener('click', () => {
                document.getElementById('controlsPanel').classList.toggle('visible');
            });

            document.getElementById('complexity').addEventListener('input', (e) => {
                CONFIG.complexity = parseInt(e.target.value);
                document.getElementById('complexityVal').textContent = e.target.value;
            });

            document.getElementById('symmetry').addEventListener('input', (e) => {
                CONFIG.symmetry = parseInt(e.target.value);
                document.getElementById('symmetryVal').textContent = e.target.value;
            });

            document.getElementById('sensitivity').addEventListener('input', (e) => {
                CONFIG.sensitivity = parseFloat(e.target.value);
                document.getElementById('sensitivityVal').textContent = e.target.value;
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                CONFIG.rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotationVal').textContent = e.target.value;
            });

            // Playback controls
            document.getElementById('playBtn').addEventListener('click', togglePlay);
            document.getElementById('progressBar').addEventListener('click', seek);

            // Start render loop
            animate();
            updateStatus('Select audio source');
        }

        function resize() {
            const dpr = Math.min(window.devicePixelRatio, 2);
            state.canvas.width = window.innerWidth * dpr;
            state.canvas.height = window.innerHeight * dpr;
            state.canvas.style.width = window.innerWidth + 'px';
            state.canvas.style.height = window.innerHeight + 'px';
            state.ctx.scale(dpr, dpr);
        }

        // =====================================================
        // AUDIO SETUP
        // =====================================================

        async function initMicrophone() {
            try {
                updateStatus('Requesting mic...');
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false }
                });

                setupAudioContext();
                state.source = state.audioContext.createMediaStreamSource(stream);
                state.source.connect(state.analyser);

                completeSetup('microphone');
                updateStatus('Listening');
            } catch (err) {
                updateStatus('Mic denied');
                console.error(err);
            }
        }

        async function initAudioFile(file) {
            try {
                updateStatus('Loading...');

                state.audioElement = new Audio();
                state.audioElement.src = URL.createObjectURL(file);
                state.audioElement.loop = true;

                await new Promise((resolve, reject) => {
                    state.audioElement.addEventListener('canplaythrough', resolve, { once: true });
                    state.audioElement.addEventListener('error', reject, { once: true });
                });

                setupAudioContext();
                state.source = state.audioContext.createMediaElementSource(state.audioElement);
                state.gainNode = state.audioContext.createGain();

                state.source.connect(state.gainNode);
                state.gainNode.connect(state.audioContext.destination);
                state.source.connect(state.analyser);

                document.getElementById('trackName').textContent = file.name.replace(/\.[^/.]+$/, '');

                await state.audioElement.play();
                state.isPlaying = true;
                updatePlayButton();

                completeSetup('file');
                updateStatus('Playing');
            } catch (err) {
                updateStatus('Load failed');
                console.error(err);
            }
        }

        function setupAudioContext() {
            state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            state.analyser = state.audioContext.createAnalyser();
            state.analyser.fftSize = CONFIG.fftSize;
            state.analyser.smoothingTimeConstant = CONFIG.smoothing;
            state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        }

        function completeSetup(mode) {
            state.isReady = true;
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('controlsBtn').classList.add('visible');
            document.getElementById('audioInfo').classList.add('visible');

            if (mode === 'file') {
                document.getElementById('playbackBar').classList.add('visible');
            }
        }

        // =====================================================
        // AUDIO ANALYSIS
        // =====================================================

        function analyzeAudio() {
            if (!state.analyser) return;

            state.analyser.getByteFrequencyData(state.dataArray);

            const len = state.dataArray.length;
            const sampleRate = state.audioContext.sampleRate;
            const binSize = (sampleRate / 2) / len;

            // Frequency band boundaries
            const bassEnd = Math.floor(250 / binSize);
            const midEnd = Math.floor(2000 / binSize);

            let bassSum = 0, midSum = 0, highSum = 0, totalSum = 0;
            let maxVal = 0, maxIdx = 0;

            for (let i = 0; i < len; i++) {
                const val = state.dataArray[i] / 255;
                totalSum += val;

                if (i < bassEnd) bassSum += val;
                else if (i < midEnd) midSum += val;
                else highSum += val;

                if (val > maxVal) {
                    maxVal = val;
                    maxIdx = i;
                }
            }

            // Normalize and apply sensitivity
            const sens = CONFIG.sensitivity;
            state.audioData.bass = Math.min(1, (bassSum / bassEnd) * sens);
            state.audioData.mid = Math.min(1, (midSum / (midEnd - bassEnd)) * sens);
            state.audioData.high = Math.min(1, (highSum / (len - midEnd)) * sens);
            state.audioData.energy = Math.min(1, (totalSum / len) * sens);
            state.audioData.dominantFreq = maxIdx * binSize;

            // Update display
            document.getElementById('freqDisplay').textContent =
                Math.round(state.audioData.dominantFreq) + ' Hz';
            document.getElementById('energyDisplay').textContent =
                Math.round(state.audioData.energy * 100) + '%';
        }

        // =====================================================
        // CYMATICS VISUALIZATION
        // Orbital geometry with vertices and connecting lines
        // =====================================================

        function drawCymatics() {
            const ctx = state.ctx;
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = w / 2;
            const cy = h / 2;
            const baseRadius = Math.min(w, h) * 0.35;

            // Clear with fade effect for trails
            ctx.fillStyle = 'rgba(0, 0, 5, 0.15)';
            ctx.fillRect(0, 0, w, h);

            if (!state.isReady) {
                // Draw idle state - subtle breathing geometry
                drawIdlePattern(ctx, cx, cy, baseRadius);
                return;
            }

            // Get audio data
            const { bass, mid, high, energy } = state.audioData;

            // Calculate pattern parameters based on audio
            const complexity = CONFIG.complexity + Math.floor(bass * 3);
            const symmetry = CONFIG.symmetry;
            const rotation = state.time * CONFIG.rotationSpeed * 0.01;

            // Draw layered orbital patterns
            drawOrbitalPattern(ctx, cx, cy, baseRadius, {
                bass, mid, high, energy,
                complexity, symmetry, rotation
            });
        }

        function drawIdlePattern(ctx, cx, cy, radius) {
            const time = state.time * 0.001;
            const breathe = 0.9 + Math.sin(time) * 0.1;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(time * 0.1);

            // Draw subtle concentric rings
            for (let i = 0; i < 5; i++) {
                const r = radius * breathe * (0.3 + i * 0.15);
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(100, 120, 200, ${0.1 - i * 0.015})`;
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw subtle vertices
            const points = 8;
            for (let i = 0; i < points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const x = Math.cos(angle) * radius * breathe * 0.5;
                const y = Math.sin(angle) * radius * breathe * 0.5;

                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(150, 150, 255, 0.2)';
                ctx.fill();
            }

            ctx.restore();
        }

        function drawOrbitalPattern(ctx, cx, cy, baseRadius, params) {
            const { bass, mid, high, energy, complexity, symmetry, rotation } = params;

            ctx.save();
            ctx.translate(cx, cy);

            // Multiple layers of orbital paths
            const layers = [
                { radiusMult: 0.3, audioMult: bass, color: [80, 120, 255], width: 2 },
                { radiusMult: 0.5, audioMult: mid, color: [150, 100, 255], width: 1.5 },
                { radiusMult: 0.7, audioMult: high, color: [200, 150, 255], width: 1 },
                { radiusMult: 0.9, audioMult: energy, color: [255, 200, 255], width: 0.5 }
            ];

            // Store all vertices for connecting lines
            const allVertices = [];

            layers.forEach((layer, layerIdx) => {
                const vertices = [];
                const r = baseRadius * layer.radiusMult * (0.8 + layer.audioMult * 0.4);
                const numPoints = symmetry * (layerIdx + 1);

                // Generate vertices along orbital path (Mereon-like pattern)
                for (let i = 0; i < numPoints; i++) {
                    const baseAngle = (i / numPoints) * Math.PI * 2;
                    const angle = baseAngle + rotation + layerIdx * 0.2;

                    // Create orbital wobble based on audio and complexity
                    const wobble = Math.sin(angle * complexity + state.time * 0.002) *
                                   layer.audioMult * 0.3;
                    const radiusVar = r * (1 + wobble);

                    // Add harmonic modulation (like atomic orbitals)
                    const harmonicX = Math.sin(angle * (complexity + 1) + state.time * 0.003) *
                                      r * 0.1 * layer.audioMult;
                    const harmonicY = Math.cos(angle * (complexity + 2) + state.time * 0.004) *
                                      r * 0.1 * layer.audioMult;

                    const x = Math.cos(angle) * radiusVar + harmonicX;
                    const y = Math.sin(angle) * radiusVar + harmonicY;

                    vertices.push({ x, y, angle });
                }

                allVertices.push({ vertices, layer });

                // Draw orbital path (the arc)
                drawOrbitalPath(ctx, vertices, layer, energy);

                // Draw vertices (crossing points)
                drawVertices(ctx, vertices, layer, energy);
            });

            // Draw connecting geometry (Euclidean lines between vertices)
            drawConnectingGeometry(ctx, allVertices, energy);

            // Draw central core
            drawCore(ctx, bass, energy);

            ctx.restore();
        }

        function drawOrbitalPath(ctx, vertices, layer, energy) {
            if (vertices.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);

            // Draw smooth curve through vertices
            for (let i = 1; i <= vertices.length; i++) {
                const curr = vertices[i % vertices.length];
                const prev = vertices[(i - 1) % vertices.length];
                const next = vertices[(i + 1) % vertices.length];

                // Control points for smooth curve
                const cpx = (prev.x + curr.x) / 2;
                const cpy = (prev.y + curr.y) / 2;

                ctx.quadraticCurveTo(prev.x, prev.y, cpx, cpy);
            }

            ctx.closePath();

            // Glow effect
            const [r, g, b] = layer.color;
            const alpha = 0.3 + energy * 0.4;
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
            ctx.lineWidth = layer.width * (1 + energy);
            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.5)`;
            ctx.shadowBlur = 10 + energy * 20;
            ctx.stroke();

            ctx.shadowBlur = 0;
        }

        function drawVertices(ctx, vertices, layer, energy) {
            const [r, g, b] = layer.color;
            const baseSize = 2 + energy * 4;

            vertices.forEach((v, i) => {
                // Pulsing size based on position and time
                const pulse = Math.sin(state.time * 0.005 + i * 0.5) * 0.3 + 0.7;
                const size = baseSize * pulse * (1 + layer.audioMult * 0.5);

                // Outer glow
                const gradient = ctx.createRadialGradient(v.x, v.y, 0, v.x, v.y, size * 3);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${0.8 * energy})`);
                gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${0.2 * energy})`);
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                ctx.beginPath();
                ctx.arc(v.x, v.y, size * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Core point
                ctx.beginPath();
                ctx.arc(v.x, v.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + energy * 0.4})`;
                ctx.fill();
            });
        }

        function drawConnectingGeometry(ctx, allVertices, energy) {
            if (energy < 0.1) return;

            // Connect vertices between layers (Euclidean geometry)
            for (let i = 0; i < allVertices.length - 1; i++) {
                const layer1 = allVertices[i];
                const layer2 = allVertices[i + 1];

                const step1 = Math.max(1, Math.floor(layer1.vertices.length / CONFIG.symmetry));
                const step2 = Math.max(1, Math.floor(layer2.vertices.length / CONFIG.symmetry));

                for (let j = 0; j < layer1.vertices.length; j += step1) {
                    const v1 = layer1.vertices[j];

                    // Find closest vertex in next layer
                    let closest = layer2.vertices[0];
                    let minDist = Infinity;

                    for (let k = 0; k < layer2.vertices.length; k += step2) {
                        const v2 = layer2.vertices[k];
                        const dist = Math.hypot(v1.x - v2.x, v1.y - v2.y);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = v2;
                        }
                    }

                    // Draw connecting line
                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(closest.x, closest.y);

                    const alpha = energy * 0.3;
                    ctx.strokeStyle = `rgba(200, 180, 255, ${alpha})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }

            // Draw internal kaleidoscope connections within each layer
            allVertices.forEach(({ vertices, layer }) => {
                const [r, g, b] = layer.color;
                const skip = Math.max(2, Math.floor(vertices.length / CONFIG.complexity));

                for (let i = 0; i < vertices.length; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + skip) % vertices.length];

                    ctx.beginPath();
                    ctx.moveTo(v1.x, v1.y);
                    ctx.lineTo(v2.x, v2.y);

                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${energy * 0.15})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            });
        }

        function drawCore(ctx, bass, energy) {
            const coreSize = 10 + bass * 30;
            const pulse = Math.sin(state.time * 0.01) * 0.2 + 1;

            // Outer glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreSize * 3 * pulse);
            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.8 * energy})`);
            gradient.addColorStop(0.3, `rgba(150, 150, 255, ${0.4 * energy})`);
            gradient.addColorStop(0.6, `rgba(100, 100, 200, ${0.1 * energy})`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 3 * pulse, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Core
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * pulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.9})`;
            ctx.fill();

            // Inner detail
            ctx.beginPath();
            ctx.arc(0, 0, coreSize * 0.5 * pulse, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(200, 200, 255, 1)`;
            ctx.fill();
        }

        // =====================================================
        // ANIMATION LOOP
        // =====================================================

        function animate() {
            requestAnimationFrame(animate);

            state.time = Date.now();

            if (state.isReady) {
                analyzeAudio();
            }

            drawCymatics();

            // Update playback progress
            if (state.audioElement && state.isPlaying) {
                updateProgress();
            }
        }

        // =====================================================
        // PLAYBACK CONTROLS
        // =====================================================

        function togglePlay() {
            if (!state.audioElement) return;

            if (state.isPlaying) {
                state.audioElement.pause();
            } else {
                state.audioElement.play();
            }
            state.isPlaying = !state.isPlaying;
            updatePlayButton();
        }

        function updatePlayButton() {
            document.getElementById('playIcon').style.display = state.isPlaying ? 'none' : 'block';
            document.getElementById('pauseIcon').style.display = state.isPlaying ? 'block' : 'none';
        }

        function seek(e) {
            if (!state.audioElement) return;
            const rect = e.target.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            state.audioElement.currentTime = percent * state.audioElement.duration;
        }

        function updateProgress() {
            if (!state.audioElement || !state.audioElement.duration) return;

            const progress = (state.audioElement.currentTime / state.audioElement.duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            const current = formatTime(state.audioElement.currentTime);
            const total = formatTime(state.audioElement.duration);
            document.getElementById('trackTime').textContent = `${current} / ${total}`;
        }

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s < 10 ? '0' : ''}${s}`;
        }

        function updateStatus(text) {
            document.getElementById('statusText').textContent = text;
        }

        // =====================================================
        // SERVICE WORKER
        // =====================================================

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(console.error);
        }

        // =====================================================
        // START
        // =====================================================

        window.addEventListener('load', init);
    </script>
</body>
</html>
